options {
    STATIC = false;
}
PARSER_BEGIN(prataLang)
import java.io.*;
public class prataLang {

  final static String Version = "PrataLang Compiler - Version 1.0 - 2024";
  boolean Menosshort = false;

  public static void main(String[] args) throws ParseException {
    String filename= ""; // nome do arquivo a ser analizado
    prataLang parser;
    int i;
    boolean ms = false;

    System.out.println(Version);

    // le os parametros passados para o compilador
    for(int i = 0; i < args.length; i++) {
      if ( args[i].toLowerCase().equals("-short") ) ms = true;
      else{
        System.out.println("Usage is: java PrataLang [-short] inputfile");
        System.exit(0);
      }
    }

    if (args[i].equals("-")){
      // le entrada padrão
       System.out.println(" Reading from standard input . . . ");
       parser = new prataLang(System.in);
    } else {
      // le do arquivo
      filename = args[args.length-1];
      System.out.println("Readig from file " + filename + " . . . ");
      try{
        parser = new prataLang(new java.io.FileInputStream(filename));
      } catch (java.io.FileNotFoundException e ) {
        System.out.println("File "+filename+ " NOT FOUND");
        return;
      }
    }
    parser.Menosshort = ms;
    parser.program(); //chama o metodo que faz a analise

    // verifica se houver erro lexico
    if (parser.token_source.foundLexError() != 0)
      System.out.println(
        parser.token_source.foundLexError() + " Erro Lexico encontrado!! "
      );
    else System.out.println(" Program successfully analized ");



  } //main

  //metodo auxiliar
  static public String im(int x) {
    int  k;
    String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try{
      s=s.substring(1,k);
    }
    catch (StringIndexOutOfBoundsException e ){ }
    return s;
  }
}

PARSER_END(prataLang)

TOKEN_MGR_DECLS : {
    int countLexError = 0;

    public int foundLexError(){
        return countLexError;

    }
}

SKIP : {
    " " | "\t" | "\n" | "\r"| "\f"  // Ignora espaços em branco e quebras de linha
}

// Multiline comment
SKIP : {
    "/*" : multilinecomment
}

<multilinecomment> SKIP : {
    "*/": DEFAULT
    | <~[]>
}

// sigle line comment
SKIP : {
    "//" : singlelinecomment
}
<singlelinecomment> SKIP: {
    <["\n","\r"]>:DEFAULT
    | <~[]>
}

// Definição de Comentários de Linha e Bloco
//SKIP : {
//    "//" ~[\r\n]* ("\r" | "\n" | "\r\n") |
//    "/*" (~["*"])* "*"+ (~["/"] (~["*"])* "*"+)* "/"
//}

// Definição de Tokens para a Linguagem

/*

* VER O LIVRO NA PARTE DOS TOKENS -> NÃO SEI A PAGINA , TA GRIFADO ALI
SEPARAR ESSE TODO AQUI

COLOCAR TOKEM:
    -> PALAVRAS RESERVADAS
    -> OPERADORES
    -> SIMBULOS ESPECIAIS
    -> CONSTANTES
    -> IDENTIFICADORES



TOKEN : {
    < IDENTIFIER: (["a"-"z", "A"-"Z"])(["a"-"z", "A"-"Z", "0"-"9", "_"])* > |
    < INTEGER: (["0"-"9"])+ > |
    < FLOAT: (["0"-"9"])+ "." (["0"-"9"])+ > |
    < STRING_LITERAL: "\"" (~["\""])* "\"" > |
    < KEYWORD_MAKE: "make" > |
    < KEYWORD_END: "end" > |
    < KEYWORD_CONST: "const" > |
    < KEYWORD_VAR: "var" > |
    < OPERATOR_PLUS: "+" > |
    < OPERATOR_MINUS: "-" > |
    < OPERATOR_MULT: "*" > |
    < OPERATOR_DIV: "/" > |
    < OPERATOR_POW: "**" > |
    < OPERATOR_MOD: "%" > |
    < OPERATOR_MOD_INT: "%%" > |
    < OPERATOR_EQ: "=" > |
    < OPERATOR_NEQ: "<>" > |
    < OPERATOR_LT: "<" > |
    < OPERATOR_GT: ">" > |
    < OPERATOR_LE: "<=" > |
    < OPERATOR_GE: ">=" > |
    < LOGICAL_AND: "&" > |
    < LOGICAL_OR: "|" > |
    < LOGICAL_NOT: "!" >
}*/

// PALAVRAS RESERVADAS
TOKEN : {
      < MAKE : "make" >
    | < END_DOT  : "end."  >
    | < END  : "end"  >
    | < END_DOT_COMMA  : "end;"  >
    | < CONST  : "const"  >
    | < INT  : "int"  >
    | < REAL  : "real"  >
    | < CHAR  : "char"  >
    | < BOOL  : "bool"  >
    | < VAR  : "var"  >
    | < GET  : "get"  >
    | < PUT  : "put"  >
    | < IF  : "if"  >
    | < THEN  : "then"  >
    | < ELSE  : "else"  >
    | < WHILE  : "while"  >
    | < DO  : "do"  >
}

// OPERADORES LOGICOS
TOKEN :
{
       < NOT : "!" >
     | < OR : "|" >
     | < END_LOGIC : "&" >
}

// OPERADORES RELACIONAIS
TOKEN :
{
       < EQUAL : "=" >
     | < DIFFERENT : "<>" >
     | < MINOR : "<" >
     | < MINOR_EQUAL : "<=" >
     | < BIGGER : ">" >
     | < BIGGER_EQUAL : ">=" >
}
// OPERADORES ARITMETRIC
TOKEN :
{
       < PLUS : "+" >
     | < MINUS : "-" >
     | < MULTIPLICATION : "*" >
     | < DIVISION : "/" >
     | < POTENCY : "**" >
     | < ENTIRE_DIVISION : "%" >
     | < DIVISION_REST : "%%" >
}
// CONSTANTES
TOKEN :
{
       < TRUE : "true" >
     | < FALSE   : "false" >
     | < int_constant  : ( //numeros decimais, octais, hexadecimais e binarios
            (["0"-"9"]  (["0"-"9"]) * ) |
            (["0"-"7"]  (["0"-"7"]) * ["o","0"]) |
            (["0"-"9"]  (["0"-"7", "A"-"F", "a"-"f"]) * ["h","H"]) |
            (["0"-"1"]  (["0"-"1"]) * ["b","B"])
         ) >
     | < string_constant : //constante string como "abcd bcda"
       "\""(~["\"","\n","\r"]) * "\""  >
     | < null_constant   : "null" >

}
TOKEN : {
    < IDENTIFIER: (["a"-"z", "A"-"Z"])(["a"-"z", "A"-"Z", "0"-"9", "_"])* > |
    < INTEGER: (["0"-"9"])+ > |
    < FLOAT: (["0"-"9"])+ "." (["0"-"9"])+ > |
    < STRING_LITERAL: "\"" (~["\""])* "\"" >
}
// IDENTIFICADORES
TOKEN :
{
      < IDENT  : <LETTER> (<LETTER>|<DIGIT>)* >
    | < LETTER : ["A" - "Z", "a" - "z"]>
    | < DIGIT  : ["0"-"9"] >
}

// SIMBULOS ESPECIAIS
//TOKEN : {}

// CONSTANTES
//TOKEN : {}

// IDENTIFICADORES
//TOKEN : {}

// Produções de Entrada para Iniciar a Análise
//void Input() : {} {
//    (Token())*
//}

//void Token() : {} {
//    < IDENTIFIER > | < INTEGER > | < FLOAT > | < STRING_LITERAL > | < KEYWORD_MAKE > |
//    < KEYWORD_END > | < KEYWORD_CONST > | < KEYWORD_VAR > | < OPERATOR_PLUS > |
//    < OPERATOR_MINUS > | < OPERATOR_MULT > | < OPERATOR_DIV > | < OPERATOR_POW > |
//    < OPERATOR_MOD > | < OPERATOR_MOD_INT > | < OPERATOR_EQ > | < OPERATOR_NEQ > |
//    < OPERATOR_LT > | < OPERATOR_GT > | < OPERATOR_LE > | < OPERATOR_GE > |
//    < LOGICAL_AND > | < LOGICAL_OR > | < LOGICAL_NOT >
//}


